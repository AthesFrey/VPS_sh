#!/usr/bin/env bash
# -----------------------------------------------------------------------------
#  realm_optimized.sh – Unified, hardened installer & manager for zhboner/realm
#  Combines the best of AthesFrey/realm.sh & AiLi/realm_manager.sh, plus fixes
#  and enhancements discussed in ChatGPT analysis (2025‑06‑04, JST).
# -----------------------------------------------------------------------------
#  Features
#  ▸ One‑command install/update/remove for Realm across x86_64 & aarch64
#  ▸ Automatic SHA256 verification of downloaded release assets
#  ▸ IPv4 ⬌ IPv6 aware rule add/remove with duplicate & syntax checks
#  ▸ Systemd unit with DynamicUser, RUST_LOG, network-online dependency
#  ▸ Service auto‑starts on boot – solves “installed but not running” issue
#  ▸ Optional cron‑based daily restart (disabled by default, enable via menu)
#  ▸ set -Eeuo pipefail, flock‑based single‑instance execution, clear UX
#  ▸ Zero external deps beyond POSIX core utils + curl + tar + systemd
# -----------------------------------------------------------------------------
#  Copyright (c) 2025, GPL‑3.0
# -----------------------------------------------------------------------------

set -Eeuo pipefail
IFS=$'\n\t'
SCRIPT_NAME="$(basename "$0")"
LOCK_FILE="/var/lock/${SCRIPT_NAME%.sh}.lock"
exec 9>"$LOCK_FILE" && flock -n 9 || { echo "Another instance is running" >&2; exit 1; }

########################
#  Global definitions  #
########################
REALM_DIR="/usr/local/bin"
REALM_BIN="${REALM_DIR}/realm"
CONFIG_DIR="/etc/realm"
CONFIG_FILE="${CONFIG_DIR}/config.toml"
SERVICE_FILE="/etc/systemd/system/realm.service"
CRON_FILE="/etc/cron.d/realm_restart"
GITHUB_BASE="https://github.com/zhboner/realm/releases/latest/download"
TMP_DIR="$(mktemp -d)"

########################
#  Helper functions    #
########################
msg()  { printf "\e[32m[+] %s\e[0m\n" "$*"; }
warn() { printf "\e[33m[!] %s\e[0m\n" "$*"; }
err()  { printf "\e[31m[-] %s\e[0m\n" "$*" >&2; exit 1; }

need_root() { (( EUID == 0 )) || err "Please run as root"; }

arch_map() {
  case "$(uname -m)" in
    x86_64) echo "x86_64-unknown-linux-gnu" ;;
    aarch64|arm64) echo "aarch64-unknown-linux-gnu" ;;
    *) err "Unsupported architecture $(uname -m)" ;;
  esac
}

download_and_verify() {
  local target="$(arch_map)" version asset sha_url sha_expected sha_got

  version=$(curl -fsSLI -o /dev/null -w '%{url_effective}' "${GITHUB_BASE}/realm-${target}.tar.gz" | sed -E 's#.*/tag/([^/]+)/.*#\1#')
  asset="realm-${target}.tar.gz"
  sha_url="${GITHUB_BASE}/${asset}.sha256sum"

  msg "Downloading Realm ${version} for ${target}";
  curl -fsSL "${GITHUB_BASE}/${asset}" -o "${TMP_DIR}/${asset}"
  sha_expected=$(curl -fsSL "${sha_url}" | awk '{print $1}')
  sha_got=$(sha256sum "${TMP_DIR}/${asset}" | awk '{print $1}')
  [[ $sha_expected == $sha_got ]] || err "SHA256 mismatch!"

  tar -xzf "${TMP_DIR}/${asset}" -C "${TMP_DIR}"
  install -Dm755 "${TMP_DIR}/realm" "${REALM_BIN}"
}

create_default_config() {
  mkdir -p "$CONFIG_DIR"
  [[ -f "$CONFIG_FILE" ]] && return 0
  cat > "$CONFIG_FILE" << 'EOF'
# Realm config generated by realm_optimized.sh
# Add rules via script menu (option 2)
[[endpoints]]  # placeholder example – remove when adding real rules
listen = "0.0.0.0:12345"
remote = "1.1.1.1:80"
protocol = "tcp"
EOF
  warn "A sample rule has been written to $CONFIG_FILE. Please edit or add proper rules."
}

write_service_file() {
  cat > "$SERVICE_FILE" << EOF
[Unit]
Description=Realm Port Forwarder
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=$REALM_BIN -c $CONFIG_FILE
Restart=on-failure
DynamicUser=yes
Environment=RUST_LOG=info
CapabilityBoundingSet=CAP_NET_BIND_SERVICE

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
}

restart_service() { systemctl restart realm.service; }

ensure_service_enabled() {
  systemctl enable --now realm.service
}

rule_exists() {
  local lport="$1"
  grep -qE "listen\s*=.*:${lport}\b" "$CONFIG_FILE"
}

format_address() {
  # Adds [] for IPv6 literals
  local addr="$1"
  [[ $addr =~ : ]] && [[ ! $addr =~ ^\[ ]] && addr="[${addr}]"
  printf "%s" "$addr"
}

add_rule() {
  read -rp "Listen port: " lport
  rule_exists "$lport" && err "Port $lport already exists in config"
  read -rp "Remote address (IPv4/IPv6): " raddr
  read -rp "Remote port: " rport
  read -rp "Protocol (tcp/udp) [tcp]: " proto
  proto=${proto:-tcp}
  raddr_formatted=$(format_address "$raddr")

  cat >> "$CONFIG_FILE" << EOF

[[endpoints]]
listen = "0.0.0.0:${lport}"
remote = "${raddr_formatted}:${rport}"
protocol = "${proto}"
EOF
  msg "Rule added. Restarting Realm..."
  restart_service
}

delete_rule() {
  read -rp "Enter listen port to delete: " lport
  TMP_CONF="${CONFIG_FILE}.tmp"
  awk -v port="$lport" -v RS="\n\n" 'BEGIN{found=0} { if ($0 ~ "listen[[:space:]]*=[[:space:]]*\".*:" port "\"") {found=1; next} ; print } END{ if(found==0) exit 1 }' "$CONFIG_FILE" > "$TMP_CONF" || err "Port $lport not found"
  mv "$TMP_CONF" "$CONFIG_FILE"
  msg "Rule deleted. Restarting Realm..."
  restart_service
}

list_rules() {
  awk '/\[\[endpoints\]\]/{blk=NR;next} blk && NR==blk+1{print $0;blk=0}' "$CONFIG_FILE" | nl -w2 -s'. '
}

setup_cron_restart() {
  if [[ -f "$CRON_FILE" ]]; then
    rm -f "$CRON_FILE" && msg "Daily restart disabled"
  else
    echo "0 5 * * * root systemctl restart realm.service" > "$CRON_FILE" && msg "Daily restart at 05:00 enabled"
  fi
}

install_realm() {
  need_root
  download_and_verify
  create_default_config
  write_service_file
  ensure_service_enabled
  msg "Realm installed and running."
}

update_realm() {
  need_root
  download_and_verify
  restart_service
  msg "Realm updated & restarted."
}

uninstall_realm() {
  need_root
  systemctl disable --now realm.service || true
  rm -f "$REALM_BIN" "$SERVICE_FILE"
  rm -rf "$CONFIG_DIR"
  rm -f "$CRON_FILE"
  systemctl daemon-reload
  msg "Realm uninstalled."
}

show_menu() {
  clear
  cat << EOF
================== Realm Manager (Optimized) ==================
1) Install / Reinstall Realm
2) Add forwarding rule
3) Delete forwarding rule
4) List rules
5) Update Realm binary
6) Enable/Disable daily auto‑restart (05:00)
7) Start / Stop / Restart / Status Realm service
8) Uninstall Realm
0) Exit
================================================================
EOF
}

manage_service() {
  PS3="Select action: "
  select act in start stop restart status back; do
    case $REPLY in
      1) systemctl start realm.service; break;;
      2) systemctl stop realm.service; break;;
      3) restart_service; break;;
      4) systemctl status --no-pager realm.service; break;;
      *) break;;
    esac
  done
}

main() {
  need_root
  while true; do
    show_menu
    read -rp "Choose: " choice
    case "$choice" in
      1) install_realm;;
      2) add_rule;;
      3) delete_rule;;
      4) list_rules; read -rp "Press Enter to continue...";;
      5) update_realm;;
      6) setup_cron_restart;;
      7) manage_service;;
      8) uninstall_realm; exit;;
      0) exit;;
      *) warn "Invalid choice";;
    esac
  done
}

main "$@"
