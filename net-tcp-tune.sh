#!/usr/bin/env bash
set -euo pipefail
#TCP窗口调优

# ---- 交互输入（提供默认值）----
read -r -p "内存大小 (GiB) [默认 1] : " MEM_G_INPUT
read -r -p "带宽 (Mbps) [默认 1000] : " BW_Mbps_INPUT
read -r -p "往返延迟 RTT (ms) [默认 75] : " RTT_ms_INPUT

MEM_G="${MEM_G_INPUT:-1}"
BW_Mbps="${BW_Mbps_INPUT:-1000}"
RTT_ms="${RTT_ms_INPUT:-75}"

# 简单的数值合法化（非数字则回退默认）
is_num() { [[ "$1" =~ ^[0-9]+([.][0-9]+)?$ ]]; }
is_int() { [[ "$1" =~ ^[0-9]+$ ]]; }

is_num "$MEM_G" || MEM_G=1
is_int "$BW_Mbps" || BW_Mbps=1000
is_num "$RTT_ms" || RTT_ms=75

# ---- 计算 BDP 与缓冲策略（单位：字节）----
# BDP(bytes) = (带宽Mbps * 1e6 / 8) * (RTT_ms / 1000) = BW_Mbps * 125 * RTT_ms
BDP_BYTES=$(awk -v bw="$BW_Mbps" -v rtt="$RTT_ms" 'BEGIN{ printf "%.0f", bw*125*rtt }')

# RAM 字节数（GiB -> bytes）
MEM_BYTES=$(awk -v g="$MEM_G" 'BEGIN{ printf "%.0f", g*1024*1024*1024 }')

# 上限策略：
# 1) 目标上限 ≈ 2×BDP，四舍五入到 {4,8,16,32,64}MB 桶
# 2) 同时不超过内存的 ~3%（上限 64MB）
round_bucket_mb() {
  local bytes=$1
  local mb=$(awk -v b="$bytes" 'BEGIN{ printf "%.0f", b/1024/1024 }')
  local bucket=4
  if   [ "$mb" -le 4  ]; then bucket=4
  elif [ "$mb" -le 8  ]; then bucket=8
  elif [ "$mb" -le 16 ]; then bucket=16
  elif [ "$mb" -le 32 ]; then bucket=32
  else bucket=64
  fi
  echo $bucket
}

TARGET_MB=$(round_bucket_mb $((BDP_BYTES*2)))
CAP_BYTES=$(awk -v m="$MEM_BYTES" 'BEGIN{ cap=m*0.03; if(cap>67108864) cap=67108864; printf "%.0f", cap }') # 3% RAM，最多64MB
CAP_MB=$(( CAP_BYTES/1024/1024 ))

# 取 min(目标桶, RAM上限)
if [ "$TARGET_MB" -gt "$CAP_MB" ]; then
  MAX_MB="$CAP_MB"
else
  MAX_MB="$TARGET_MB"
fi

# 至少 4MB，上限最多 64MB
[ "$MAX_MB" -lt 4 ] && MAX_MB=4
[ "$MAX_MB" -gt 64 ] && MAX_MB=64

MAX_BYTES=$(( MAX_MB*1024*1024 ))

# 默认窗口：随上限阶梯设定
# 8/16MB -> 128K/256K；≥32MB -> 256K/512K；4MB -> 128K/128K
if   [ "$MAX_MB" -ge 32 ]; then
  DEF_R=262144   # 256KB
  DEF_W=524288   # 512KB
elif [ "$MAX_MB" -ge 8 ]; then
  DEF_R=131072   # 128KB
  DEF_W=262144   # 256KB
else
  DEF_R=131072   # 128KB
  DEF_W=131072   # 128KB
fi

# ---- 查询默认 IPv4 出口网卡 ----
IFACE="$(ip -o -4 route show to default 2>/dev/null | awk '{print $5}' | head -1 || true)"

# ---- 尝试加载 BBR（若为内置则无影响）----
if command -v modprobe >/dev/null 2>&1; then
  modprobe tcp_bbr 2>/dev/null || true
fi

# ---- 直接写入配置文件（加载顺序靠后）----
cat >/etc/sysctl.d/999-net-bbr-fq.conf <<EOF
# Generated by net-tcp-tune.sh
# Host memory: ${MEM_G} GiB, Bandwidth: ${BW_Mbps} Mbps, RTT: ${RTT_ms} ms
# Computed BDP: ${BDP_BYTES} bytes (~$(awk -v b="$BDP_BYTES" 'BEGIN{ printf "%.2f", b/1024/1024 }') MB)
# Buffer cap: ${MAX_MB} MB (RAM 3% capped <= 64MB)

# BBR + pacing（fq）
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr

# 健壮性与首包/恢复
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_sack = 1
net.ipv4.tcp_moderate_rcvbuf = 1
# ECN 协商允许（遇到不兼容中间盒会自动回退）
net.ipv4.tcp_ecn = 1

# 缓冲上限与默认值（min/default/max）
net.core.rmem_max = ${MAX_BYTES}
net.core.wmem_max = ${MAX_BYTES}
net.ipv4.tcp_rmem = 4096 ${DEF_R} ${MAX_BYTES}
net.ipv4.tcp_wmem = 4096 ${DEF_W} ${MAX_BYTES}

# 更安全的 TIME-WAIT 处理
net.ipv4.tcp_rfc1337 = 1

# rpf 宽松（常见服务器建议，避免多宿主/隧道被误杀）
net.ipv4.conf.all.rp_filter = 0
net.ipv4.conf.default.rp_filter = 0
EOF

chmod 0644 /etc/sysctl.d/999-net-bbr-fq.conf

# ---- 应用配置 ----
sysctl --system >/dev/null

# ---- 若可用，立刻将默认网卡根队列切到 fq（即时生效）----
if command -v tc >/dev/null 2>&1 && [ -n "${IFACE:-}" ]; then
  tc qdisc replace dev "$IFACE" root fq 2>/dev/null || true
fi

# ---- 回显关键结果 ----
echo "==== RESULT ===="
echo "内存: ${MEM_G} GiB, 带宽: ${BW_Mbps} Mbps, RTT: ${RTT_ms} ms"
echo "BDP≈ ${BDP_BYTES} bytes (~$(awk -v b="$BDP_BYTES" 'BEGIN{ printf "%.2f", b/1024/1024 }') MB)"
echo "缓冲上限: ${MAX_MB} MB ; 默认 rmem=${DEF_R} / wmem=${DEF_W}"
echo
sysctl net.ipv4.tcp_congestion_control
sysctl net.core.default_qdisc
sysctl net.core.rmem_max net.core.wmem_max
sysctl net.ipv4.tcp_rmem net.ipv4.tcp_wmem
sysctl net.ipv4.tcp_mtu_probing net.ipv4.tcp_fastopen
sysctl net.ipv4.tcp_ecn net.ipv4.tcp_sack net.ipv4.tcp_timestamps
sysctl net.ipv4.tcp_rfc1337
if command -v tc >/dev/null 2>&1 && [ -n "${IFACE:-}" ]; then
  echo "qdisc on ${IFACE}:"
  tc qdisc show dev "$IFACE" || true
fi
echo "==============="
