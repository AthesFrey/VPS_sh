#!/usr/bin/env bash
set -euo pipefail

# -------------------------------
# 交互式 TCP/BBR 调优脚本（默认 RTT=150ms）
# 适配：Ubuntu 22.04/24.04、Debian 11/12/（预期）13
# 写入：/etc/sysctl.d/999-net-bbr-fq.conf（加载顺序靠后，避免被覆盖）
# -------------------------------

# 提示并读取（默认：内存=1 GiB，带宽=1000 Mbps，RTT=150 ms）
read -r -p "内存大小 (GiB) [默认 1] : " MEM_G_INPUT
read -r -p "带宽 (Mbps) [默认 1000] : " BW_Mbps_INPUT
read -r -p "往返延迟 RTT (ms) [默认 150] : " RTT_ms_INPUT

MEM_G="${MEM_G_INPUT:-1}"
BW_Mbps="${BW_Mbps_INPUT:-1000}"
RTT_ms="${RTT_ms_INPUT:-150}"

is_num() { [[ "$1" =~ ^[0-9]+([.][0-9]+)?$ ]]; }
is_int() { [[ "$1" =~ ^[0-9]+$ ]]; }

is_num "$MEM_G"   || MEM_G=1
is_int "$BW_Mbps" || BW_Mbps=1000
is_num "$RTT_ms"  || RTT_ms=150

# BDP(bytes) = BW(Mbps)*125*RTT(ms)
BDP_BYTES=$(awk -v bw="$BW_Mbps" -v rtt="$RTT_ms" 'BEGIN{ printf "%.0f", bw*125*rtt }')
MEM_BYTES=$(awk -v g="$MEM_G" 'BEGIN{ printf "%.0f", g*1024*1024*1024 }')

# 目标：max_bytes = min(2*BDP, RAM*3%, 64MB)
TWO_BDP=$(( BDP_BYTES*2 ))
RAM3_BYTES=$(awk -v m="$MEM_BYTES" 'BEGIN{ printf "%.0f", m*0.03 }')
# 64MB 上限
CAP64=$(( 64*1024*1024 ))

min3() {
  local a=$1 b=$2 c=$3
  local m=$a; [ $b -lt $m ] && m=$b; [ $c -lt $m ] && m=$c; echo $m
}
MAX_NUM_BYTES=$(min3 "$TWO_BDP" "$RAM3_BYTES" "$CAP64")

# 向下就近到 {4,8,16,32,64} MB 桶值；最小地板 4MB
bucket_le_mb() {
  local mb=$1
  if   [ "$mb" -ge 64 ]; then echo 64
  elif [ "$mb" -ge 32 ]; then echo 32
  elif [ "$mb" -ge 16 ]; then echo 16
  elif [ "$mb" -ge 8  ]; then echo 8
  elif [ "$mb" -ge 4  ]; then echo 4
  else echo 4
  fi
}

MAX_MB_NUM=$(( MAX_NUM_BYTES/1024/1024 ))
MAX_MB=$(bucket_le_mb "$MAX_MB_NUM")
MAX_BYTES=$(( MAX_MB*1024*1024 ))

# 默认窗口：跟随桶值
# 4MB → r/w=128K；8/16MB → 128K/256K；≥32MB → 256K/512K
if   [ "$MAX_MB" -ge 32 ]; then
  DEF_R=262144   # 256KB
  DEF_W=524288   # 512KB
elif [ "$MAX_MB" -ge 8 ]; then
  DEF_R=131072   # 128KB
  DEF_W=262144   # 256KB
else
  DEF_R=131072   # 128KB
  DEF_W=131072   # 128KB
fi

# 默认路由网卡（可能为空）
IFACE="$(ip -o -4 route show to default 2>/dev/null | awk '{print $5}' | head -1 || true)"

# 尝试加载 BBR（若为内置则无影响）
if command -v modprobe >/dev/null 2>&1; then
  modprobe tcp_bbr 2>/dev/null || true
fi

# 直接生成最终配置（默认 RTT=150 的备注已更新）
cat >/etc/sysctl.d/999-net-bbr-fq.conf <<EOF
# Generated by net-tcp-tune.sh
# Host memory: ${MEM_G} GiB, Bandwidth: ${BW_Mbps} Mbps, RTT: ${RTT_ms} ms (默认 150)
# Computed BDP: ${BDP_BYTES} bytes (~$(awk -v b="$BDP_BYTES" 'BEGIN{ printf "%.2f", b/1024/1024 }') MB)
# Buffer cap (bucketized): ${MAX_MB} MB (min of 2*BDP, RAM 3%, 64MB; rounded down to {4,8,16,32,64}MB)

# BBR + pacing（fq）
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr

# 健壮性与首包/恢复
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_sack = 1
net.ipv4.tcp_moderate_rcvbuf = 1
# ECN 协商允许（遇到不兼容中间盒会自动回退）
net.ipv4.tcp_ecn = 1

# 缓冲上限与默认值（min/default/max）
net.core.rmem_max = ${MAX_BYTES}
net.core.wmem_max = ${MAX_BYTES}
net.ipv4.tcp_rmem = 4096 ${DEF_R} ${MAX_BYTES}
net.ipv4.tcp_wmem = 4096 ${DEF_W} ${MAX_BYTES}

# 更安全的 TIME-WAIT 处理
net.ipv4.tcp_rfc1337 = 1

# rpf 宽松（常见服务器建议，避免多宿主/隧道被误杀）
net.ipv4.conf.all.rp_filter = 0
net.ipv4.conf.default.rp_filter = 0
EOF

chmod 0644 /etc/sysctl.d/999-net-bbr-fq.conf

# 应用配置
sysctl --system >/dev/null

# 立刻把当前默认网卡根队列切到 fq（无 tc 或无网卡则跳过）
if command -v tc >/dev/null 2>&1 && [ -n "${IFACE:-}" ]; then
  tc qdisc replace dev "$IFACE" root fq 2>/dev/null || true
fi

# 反馈结果
echo "==== RESULT ===="
echo "内存: ${MEM_G} GiB, 带宽: ${BW_Mbps} Mbps, RTT: ${RTT_ms} ms"
echo "BDP≈ ${BDP_BYTES} bytes (~$(awk -v b="$BDP_BYTES" 'BEGIN{ printf \"%.2f\", b/1024/1024 }') MB)"
echo "2*BDP≈ $((TWO_BDP)) bytes ; RAM*3%≈ ${RAM3_BYTES} bytes ; cap≤64MB"
echo "最终缓冲上限(桶值): ${MAX_MB} MB"
echo "默认窗口: rmem=${DEF_R} bytes ; wmem=${DEF_W} bytes"
echo "配置文件: /etc/sysctl.d/999-net-bbr-fq.conf"
sysctl net.ipv4.tcp_congestion_control
sysctl net.core.default_qdisc
sysctl net.core.rmem_max net.core.wmem_max
sysctl net.ipv4.tcp_rmem net.ipv4.tcp_wmem
sysctl net.ipv4.tcp_mtu_probing net.ipv4.tcp_fastopen
sysctl net.ipv4.tcp_ecn net.ipv4.tcp_sack net.ipv4.tcp_timestamps
sysctl net.ipv4.tcp_rfc1337
if command -v tc >/dev/null 2>&1 && [ -n "${IFACE:-}" ]; then
  echo "qdisc on ${IFACE}:"
  tc qdisc show dev "$IFACE" || true
fi
echo "==============="
